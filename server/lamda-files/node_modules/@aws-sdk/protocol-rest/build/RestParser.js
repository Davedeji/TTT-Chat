"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var is_array_buffer_1 = require("@aws-sdk/is-array-buffer");
var protocol_timestamp_1 = require("@aws-sdk/protocol-timestamp");
var response_metadata_extractor_1 = require("@aws-sdk/response-metadata-extractor");
var RestParser = /** @class */ (function () {
    function RestParser(bodyParser, bodyCollector, parseServiceException, utf8Encoder, base64Decoder) {
        this.bodyParser = bodyParser;
        this.bodyCollector = bodyCollector;
        this.parseServiceException = parseServiceException;
        this.utf8Encoder = utf8Encoder;
        this.base64Decoder = base64Decoder;
    }
    RestParser.prototype.parse = function (operation, input) {
        var _this = this;
        var output = {};
        var responseHeaders = input.headers;
        output.$metadata = response_metadata_extractor_1.extractMetadata(input);
        if (this.responseIsSuccessful(input.statusCode)) {
            this.parseHeaders(output, responseHeaders, operation.output);
            this.parseStatusCode(output, input.statusCode, operation.output);
            return this.parseBody(output, operation.output, input);
        }
        else {
            return this.resolveBodyString(input.body).then(function (body) {
                throw _this.parseServiceException(operation, tslib_1.__assign({}, input, { body: body }), _this.bodyParser);
            });
        }
    };
    RestParser.prototype.parseBody = function (output, member, response) {
        var _this = this;
        // determine if the member references a payload member
        var shape = member.shape;
        var body = response.body;
        var payloadName = shape.payload;
        if (payloadName) {
            var payloadMember_1 = shape.members[payloadName];
            var payloadShape_1 = payloadMember_1.shape;
            if (payloadShape_1.type === "blob") {
                if (payloadMember_1.streaming || payloadShape_1.streaming) {
                    output[payloadName] = body;
                    return Promise.resolve(output);
                }
                // non-streaming blobs should always be byte arrays
                return this.resolveBody(body).then(function (buffer) {
                    output[payloadName] = buffer;
                    return output;
                });
            }
            else {
                return this.resolveBodyString(body).then(function (body) {
                    if (payloadShape_1.type === "structure" ||
                        payloadShape_1.type === "list" ||
                        payloadShape_1.type === "map") {
                        output[payloadName] = _this.bodyParser.parse(payloadMember_1, body);
                    }
                    else {
                        output[payloadName] = _this.parseScalarBody(payloadShape_1, body);
                    }
                    return output;
                });
            }
        }
        else {
            return this.resolveBodyString(body).then(function (body) {
                var e_1, _a;
                if (body.length > 0) {
                    var parsedBody = _this.bodyParser.parse(member, body);
                    try {
                        for (var _b = tslib_1.__values(Object.keys(parsedBody)), _c = _b.next(); !_c.done; _c = _b.next()) {
                            var key = _c.value;
                            output[key] = parsedBody[key];
                        }
                    }
                    catch (e_1_1) { e_1 = { error: e_1_1 }; }
                    finally {
                        try {
                            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                        }
                        finally { if (e_1) throw e_1.error; }
                    }
                }
                return Promise.resolve(output);
            });
        }
    };
    RestParser.prototype.parseHeaders = function (output, inputHeaders, member) {
        var e_2, _a, e_3, _b, e_4, _c;
        if (member.shape.type !== "structure") {
            return;
        }
        var lowerInputHeaders = {};
        try {
            // transform response headers into lowercase for easier comparisons
            for (var _d = tslib_1.__values(Object.keys(inputHeaders)), _e = _d.next(); !_e.done; _e = _d.next()) {
                var header = _e.value;
                lowerInputHeaders[header.toLowerCase()] = inputHeaders[header];
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_e && !_e.done && (_a = _d.return)) _a.call(_d);
            }
            finally { if (e_2) throw e_2.error; }
        }
        var members = member.shape.members;
        try {
            for (var _f = tslib_1.__values(Object.keys(members)), _g = _f.next(); !_g.done; _g = _f.next()) {
                var memberName = _g.value;
                var member_1 = members[memberName];
                var location = member_1.location, _h = member_1.locationName, locationName = _h === void 0 ? memberName : _h, memberShape = member_1.shape;
                var hasLocationName = Boolean(member_1.locationName);
                if (location !== "header" && location !== "headers") {
                    continue;
                }
                var ruleHeaderName = locationName.toLowerCase();
                var inputHeaderValue = lowerInputHeaders[ruleHeaderName];
                if (memberShape.type === "map") {
                    output[memberName] = {};
                    var regex = new RegExp("^" + locationName + "(.+)", "i");
                    try {
                        // iterate over each header
                        for (var _j = tslib_1.__values(Object.keys(inputHeaders)), _k = _j.next(); !_k.done; _k = _j.next()) {
                            var header = _k.value;
                            var result = header.match(regex);
                            if (result) {
                                output[memberName][result[1]] = inputHeaders[header];
                            }
                        }
                    }
                    catch (e_4_1) { e_4 = { error: e_4_1 }; }
                    finally {
                        try {
                            if (_k && !_k.done && (_c = _j.return)) _c.call(_j);
                        }
                        finally { if (e_4) throw e_4.error; }
                    }
                }
                else {
                    if (typeof inputHeaderValue !== "undefined") {
                        output[memberName] = this.parseScalarHeader(memberShape, inputHeaderValue);
                    }
                }
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (_g && !_g.done && (_b = _f.return)) _b.call(_f);
            }
            finally { if (e_3) throw e_3.error; }
        }
    };
    RestParser.prototype.parseScalarBody = function (shape, input) {
        switch (shape.type) {
            case "timestamp":
                return protocol_timestamp_1.toDate(input);
            case "string":
                if (typeof input === "string") {
                    return input;
                }
                else {
                    return this.utf8Encoder(input);
                }
            case "boolean":
                return typeof input === "boolean" ? input : input === "true";
            case "integer":
                return parseInt(input, 10);
            case "float":
                return parseFloat(input);
        }
    };
    RestParser.prototype.parseScalarHeader = function (shape, input) {
        switch (shape.type) {
            case "timestamp":
                return protocol_timestamp_1.toDate(input);
            case "string":
                return shape.jsonValue
                    ? JSON.parse(this.utf8Encoder(this.base64Decoder(input)))
                    : input;
            case "boolean":
                return input === "true";
            case "integer":
                return parseInt(input, 10);
            case "float":
                return parseFloat(input);
            case "blob":
                return this.base64Decoder(input);
        }
    };
    RestParser.prototype.parseStatusCode = function (output, statusCode, member) {
        var e_5, _a;
        if (!statusCode) {
            return;
        }
        var shape = member.shape;
        var members = shape.members;
        try {
            for (var _b = tslib_1.__values(Object.keys(members)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var memberName = _c.value;
                var member_2 = members[memberName];
                if (member_2.location === "statusCode") {
                    var name = member_2.locationName || memberName;
                    output[name] = statusCode;
                    return;
                }
            }
        }
        catch (e_5_1) { e_5 = { error: e_5_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_5) throw e_5.error; }
        }
    };
    RestParser.prototype.resolveBody = function (body) {
        if (body === void 0) { body = ""; }
        if (typeof body === "string") {
            return Promise.resolve(body);
        }
        var bufferPromise;
        if (ArrayBuffer.isView(body)) {
            bufferPromise = Promise.resolve(new Uint8Array(body.buffer, body.byteOffset, body.byteLength));
        }
        else if (is_array_buffer_1.isArrayBuffer(body)) {
            bufferPromise = Promise.resolve(new Uint8Array(body, 0, body.byteLength));
        }
        else {
            bufferPromise = this.bodyCollector(body);
        }
        return bufferPromise;
    };
    RestParser.prototype.resolveBodyString = function (body) {
        var _this = this;
        if (body === void 0) { body = ""; }
        return this.resolveBody(body).then(function (buffer) {
            return typeof buffer === "string" ? buffer : _this.utf8Encoder(buffer);
        });
    };
    RestParser.prototype.responseIsSuccessful = function (statusCode) {
        return statusCode < 300;
    };
    return RestParser;
}());
exports.RestParser = RestParser;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUmVzdFBhcnNlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy9SZXN0UGFyc2VyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLDREQUF5RDtBQUN6RCxrRUFBcUQ7QUFDckQsb0ZBQXVFO0FBa0J2RTtJQUNFLG9CQUNtQixVQUFzQixFQUN0QixhQUEwQyxFQUMxQyxxQkFBNkMsRUFDN0MsV0FBb0IsRUFDcEIsYUFBc0I7UUFKdEIsZUFBVSxHQUFWLFVBQVUsQ0FBWTtRQUN0QixrQkFBYSxHQUFiLGFBQWEsQ0FBNkI7UUFDMUMsMEJBQXFCLEdBQXJCLHFCQUFxQixDQUF3QjtRQUM3QyxnQkFBVyxHQUFYLFdBQVcsQ0FBUztRQUNwQixrQkFBYSxHQUFiLGFBQWEsQ0FBUztJQUN0QyxDQUFDO0lBRUcsMEJBQUssR0FBWixVQUNFLFNBQXlCLEVBQ3pCLEtBQStCO1FBRmpDLGlCQXNCQztRQWxCQyxJQUFNLE1BQU0sR0FBd0IsRUFBRSxDQUFDO1FBQy9CLElBQUEsK0JBQXdCLENBQVc7UUFDM0MsTUFBTSxDQUFDLFNBQVMsR0FBRyw2Q0FBZSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQzFDLElBQUksSUFBSSxDQUFDLG9CQUFvQixDQUFDLEtBQUssQ0FBQyxVQUFVLENBQUMsRUFBRTtZQUMvQyxJQUFJLENBQUMsWUFBWSxDQUFDLE1BQU0sRUFBRSxlQUFlLEVBQUUsU0FBUyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1lBQzdELElBQUksQ0FBQyxlQUFlLENBQUMsTUFBTSxFQUFFLEtBQUssQ0FBQyxVQUFVLEVBQUUsU0FBUyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1lBQ2pFLE9BQU8sSUFBSSxDQUFDLFNBQVMsQ0FBQyxNQUFNLEVBQUUsU0FBUyxDQUFDLE1BQU0sRUFBRSxLQUFLLENBRXBELENBQUM7U0FDSDthQUFNO1lBQ0wsT0FBTyxJQUFJLENBQUMsaUJBQWlCLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxV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QUFDLENBQUMsS0FBSSxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUM7UUFBOUQsQ0FBOEQsQ0FDL0QsQ0FBQztJQUNKLENBQUM7SUFFTyx5Q0FBb0IsR0FBNUIsVUFBNkIsVUFBa0I7UUFDN0MsT0FBTyxVQUFVLEdBQUcsR0FBRyxDQUFDO0lBQzFCLENBQUM7SUFDSCxpQkFBQztBQUFELENBQUMsQUFsT0QsSUFrT0M7QUFsT1ksZ0NBQVUiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBpc0FycmF5QnVmZmVyIH0gZnJvbSBcIkBhd3Mtc2RrL2lzLWFycmF5LWJ1ZmZlclwiO1xuaW1wb3J0IHsgdG9EYXRlIH0gZnJvbSBcIkBhd3Mtc2RrL3Byb3RvY29sLXRpbWVzdGFtcFwiO1xuaW1wb3J0IHsgZXh0cmFjdE1ldGFkYXRhIH0gZnJvbSBcIkBhd3Mtc2RrL3Jlc3BvbnNlLW1ldGFkYXRhLWV4dHJhY3RvclwiO1xuaW1wb3J0IHsgaW5pdFNlcnZpY2VFeGNlcHRpb24gfSBmcm9tIFwiQGF3cy1zZGsvdXRpbC1lcnJvci1jb25zdHJ1Y3RvclwiO1xuaW1wb3J0IHtcbiAgQm9keVBhcnNlcixcbiAgRGVjb2RlcixcbiAgRW5jb2RlcixcbiAgSGVhZGVyQmFnLFxuICBIdHRwUmVzcG9uc2UsXG4gIE1lbWJlcixcbiAgTWV0YWRhdGFCZWFyZXIsXG4gIE9wZXJhdGlvbk1vZGVsLFxuICBSZXNwb25zZVBhcnNlcixcbiAgU2VyaWFsaXphdGlvbk1vZGVsLFxuICBTdHJlYW1Db2xsZWN0b3IsXG4gIFN0cnVjdHVyZSxcbiAgU2VydmljZUV4Y2VwdGlvblBhcnNlclxufSBmcm9tIFwiQGF3cy1zZGsvdHlwZXNcIjtcblxuZXhwb3J0IGNsYXNzIFJlc3RQYXJzZXI8U3RyZWFtVHlwZT4gaW1wbGVtZW50cyBSZXNwb25zZVBhcnNlcjxTdHJlYW1UeXBlPiB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgcmVhZG9ubHkgYm9keVBhcnNlcjogQm9keVBhcnNlcixcbiAgICBwcml2YXRlIHJlYWRvbmx5IGJvZHlDb2xsZWN0b3I6IFN0cmVhbUNvbGxlY3RvcjxTdHJlYW1UeXBlPixcbiAgICBwcml2YXRlIHJlYWRvbmx5IHBhcnNlU2VydmljZUV4Y2VwdGlvbjogU2VydmljZUV4Y2VwdGlvblBhcnNlcixcbiAgICBwcml2YXRlIHJlYWRvbmx5IHV0ZjhFbmNvZGVyOiBFbmNvZGVyLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgYmFzZTY0RGVjb2RlcjogRGVjb2RlclxuICApIHt9XG5cbiAgcHVibGljIHBhcnNlPE91dHB1dFR5cGUgZXh0ZW5kcyBNZXRhZGF0YUJlYXJlcj4oXG4gICAgb3BlcmF0aW9uOiBPcGVyYXRpb25Nb2RlbCxcbiAgICBpbnB1dDogSHR0cFJlc3BvbnNlPFN0cmVhbVR5cGU+XG4gICk6IFByb21pc2U8T3V0cHV0VHlwZT4ge1xuICAgIGNvbnN0IG91dHB1dDogUGFydGlhbDxPdXRwdXRUeXBlPiA9IHt9O1xuICAgIGNvbnN0IHsgaGVhZGVyczogcmVzcG9uc2VIZWFkZXJzIH0gPSBpbnB1dDtcbiAgICBvdXRwdXQuJG1ldGFkYXRhID0gZXh0cmFjdE1ldGFkYXRhKGlucHV0KTtcbiAgICBpZiAodGhpcy5yZXNwb25zZUlzU3VjY2Vzc2Z1bChpbnB1dC5zdGF0dXNDb2RlKSkge1xuICAgICAgdGhpcy5wYXJzZUhlYWRlcnMob3V0cHV0LCByZXNwb25zZUhlYWRlcnMsIG9wZXJhdGlvbi5vdXRwdXQpO1xuICAgICAgdGhpcy5wYXJzZVN0YXR1c0NvZGUob3V0cHV0LCBpbnB1dC5zdGF0dXNDb2RlLCBvcGVyYXRpb24ub3V0cHV0KTtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlQm9keShvdXRwdXQsIG9wZXJhdGlvbi5vdXRwdXQsIGlucHV0KSBhcyBQcm9taXNlPFxuICAgICAgICBPdXRwdXRUeXBlXG4gICAgICA+O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5yZXNvbHZlQm9keVN0cmluZyhpbnB1dC5ib2R5KS50aGVuKGJvZHkgPT4ge1xuICAgICAgICB0aHJvdyB0aGlzLnBhcnNlU2VydmljZUV4Y2VwdGlvbihcbiAgICAgICAgICBvcGVyYXRpb24sXG4gICAgICAgICAgeyAuLi5pbnB1dCwgYm9keSB9LFxuICAgICAgICAgIHRoaXMuYm9keVBhcnNlclxuICAgICAgICApO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBwYXJzZUJvZHkoXG4gICAgb3V0cHV0OiBhbnksXG4gICAgbWVtYmVyOiBNZW1iZXIsXG4gICAgcmVzcG9uc2U6IEh0dHBSZXNwb25zZTxTdHJlYW1UeXBlPlxuICApOiBQcm9taXNlPGFueT4ge1xuICAgIC8vIGRldGVybWluZSBpZiB0aGUgbWVtYmVyIHJlZmVyZW5jZXMgYSBwYXlsb2FkIG1lbWJlclxuICAgIGNvbnN0IHNoYXBlID0gbWVtYmVyLnNoYXBlIGFzIFN0cnVjdHVyZTtcblxuICAgIGNvbnN0IGJvZHkgPSByZXNwb25zZS5ib2R5O1xuXG4gICAgY29uc3QgcGF5bG9hZE5hbWUgPSBzaGFwZS5wYXlsb2FkO1xuXG4gICAgaWYgKHBheWxvYWROYW1lKSB7XG4gICAgICBjb25zdCBwYXlsb2FkTWVtYmVyID0gc2hhcGUubWVtYmVyc1twYXlsb2FkTmFtZV07XG4gICAgICBjb25zdCBwYXlsb2FkU2hhcGUgPSBwYXlsb2FkTWVtYmVyLnNoYXBlO1xuXG4gICAgICBpZiAocGF5bG9hZFNoYXBlLnR5cGUgPT09IFwiYmxvYlwiKSB7XG4gICAgICAgIGlmIChwYXlsb2FkTWVtYmVyLnN0cmVhbWluZyB8fCBwYXlsb2FkU2hhcGUuc3RyZWFtaW5nKSB7XG4gICAgICAgICAgb3V0cHV0W3BheWxvYWROYW1lXSA9IGJvZHk7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShvdXRwdXQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIG5vbi1zdHJlYW1pbmcgYmxvYnMgc2hvdWxkIGFsd2F5cyBiZSBieXRlIGFycmF5c1xuICAgICAgICByZXR1cm4gdGhpcy5yZXNvbHZlQm9keShib2R5KS50aGVuKGJ1ZmZlciA9PiB7XG4gICAgICAgICAgb3V0cHV0W3BheWxvYWROYW1lXSA9IGJ1ZmZlcjtcbiAgICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc29sdmVCb2R5U3RyaW5nKGJvZHkpLnRoZW4oYm9keSA9PiB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgcGF5bG9hZFNoYXBlLnR5cGUgPT09IFwic3RydWN0dXJlXCIgfHxcbiAgICAgICAgICAgIHBheWxvYWRTaGFwZS50eXBlID09PSBcImxpc3RcIiB8fFxuICAgICAgICAgICAgcGF5bG9hZFNoYXBlLnR5cGUgPT09IFwibWFwXCJcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIG91dHB1dFtwYXlsb2FkTmFtZV0gPSB0aGlzLmJvZHlQYXJzZXIucGFyc2UocGF5bG9hZE1lbWJlciwgYm9keSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG91dHB1dFtwYXlsb2FkTmFtZV0gPSB0aGlzLnBhcnNlU2NhbGFyQm9keShwYXlsb2FkU2hhcGUsIGJvZHkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMucmVzb2x2ZUJvZHlTdHJpbmcoYm9keSkudGhlbihib2R5ID0+IHtcbiAgICAgICAgaWYgKGJvZHkubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGNvbnN0IHBhcnNlZEJvZHk6IGFueSA9IHRoaXMuYm9keVBhcnNlci5wYXJzZShtZW1iZXIsIGJvZHkpO1xuICAgICAgICAgIGZvciAobGV0IGtleSBvZiBPYmplY3Qua2V5cyhwYXJzZWRCb2R5KSkge1xuICAgICAgICAgICAgb3V0cHV0W2tleV0gPSBwYXJzZWRCb2R5W2tleV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUob3V0cHV0KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgcGFyc2VIZWFkZXJzKFxuICAgIG91dHB1dDogYW55LFxuICAgIGlucHV0SGVhZGVyczogSGVhZGVyQmFnLFxuICAgIG1lbWJlcjogTWVtYmVyXG4gICk6IHZvaWQge1xuICAgIGlmIChtZW1iZXIuc2hhcGUudHlwZSAhPT0gXCJzdHJ1Y3R1cmVcIikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBsb3dlcklucHV0SGVhZGVyczogSGVhZGVyQmFnID0ge307XG5cbiAgICAvLyB0cmFuc2Zvcm0gcmVzcG9uc2UgaGVhZGVycyBpbnRvIGxvd2VyY2FzZSBmb3IgZWFzaWVyIGNvbXBhcmlzb25zXG4gICAgZm9yIChsZXQgaGVhZGVyIG9mIE9iamVjdC5rZXlzKGlucHV0SGVhZGVycykpIHtcbiAgICAgIGxvd2VySW5wdXRIZWFkZXJzW2hlYWRlci50b0xvd2VyQ2FzZSgpXSA9IGlucHV0SGVhZGVyc1toZWFkZXJdO1xuICAgIH1cblxuICAgIGNvbnN0IG1lbWJlcnMgPSBtZW1iZXIuc2hhcGUubWVtYmVycztcblxuICAgIGZvciAobGV0IG1lbWJlck5hbWUgb2YgT2JqZWN0LmtleXMobWVtYmVycykpIHtcbiAgICAgIGxldCBtZW1iZXIgPSBtZW1iZXJzW21lbWJlck5hbWVdO1xuICAgICAgbGV0IHsgbG9jYXRpb24sIGxvY2F0aW9uTmFtZSA9IG1lbWJlck5hbWUsIHNoYXBlOiBtZW1iZXJTaGFwZSB9ID0gbWVtYmVyO1xuICAgICAgY29uc3QgaGFzTG9jYXRpb25OYW1lID0gQm9vbGVhbihtZW1iZXIubG9jYXRpb25OYW1lKTtcblxuICAgICAgaWYgKGxvY2F0aW9uICE9PSBcImhlYWRlclwiICYmIGxvY2F0aW9uICE9PSBcImhlYWRlcnNcIikge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJ1bGVIZWFkZXJOYW1lID0gbG9jYXRpb25OYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICBjb25zdCBpbnB1dEhlYWRlclZhbHVlID0gbG93ZXJJbnB1dEhlYWRlcnNbcnVsZUhlYWRlck5hbWVdO1xuXG4gICAgICBpZiAobWVtYmVyU2hhcGUudHlwZSA9PT0gXCJtYXBcIikge1xuICAgICAgICBvdXRwdXRbbWVtYmVyTmFtZV0gPSB7fTtcbiAgICAgICAgY29uc3QgcmVnZXggPSBuZXcgUmVnRXhwKGBeJHtsb2NhdGlvbk5hbWV9KC4rKWAsIFwiaVwiKTtcbiAgICAgICAgLy8gaXRlcmF0ZSBvdmVyIGVhY2ggaGVhZGVyXG4gICAgICAgIGZvciAobGV0IGhlYWRlciBvZiBPYmplY3Qua2V5cyhpbnB1dEhlYWRlcnMpKSB7XG4gICAgICAgICAgbGV0IHJlc3VsdCA9IGhlYWRlci5tYXRjaChyZWdleCk7XG4gICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgb3V0cHV0W21lbWJlck5hbWVdW3Jlc3VsdFsxXV0gPSBpbnB1dEhlYWRlcnNbaGVhZGVyXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXRIZWFkZXJWYWx1ZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgIG91dHB1dFttZW1iZXJOYW1lXSA9IHRoaXMucGFyc2VTY2FsYXJIZWFkZXIoXG4gICAgICAgICAgICBtZW1iZXJTaGFwZSxcbiAgICAgICAgICAgIGlucHV0SGVhZGVyVmFsdWVcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBwYXJzZVNjYWxhckJvZHkoc2hhcGU6IFNlcmlhbGl6YXRpb25Nb2RlbCwgaW5wdXQ6IGFueSkge1xuICAgIHN3aXRjaCAoc2hhcGUudHlwZSkge1xuICAgICAgY2FzZSBcInRpbWVzdGFtcFwiOlxuICAgICAgICByZXR1cm4gdG9EYXRlKGlucHV0KTtcbiAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIHJldHVybiBpbnB1dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy51dGY4RW5jb2RlcihpbnB1dCk7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgIHJldHVybiB0eXBlb2YgaW5wdXQgPT09IFwiYm9vbGVhblwiID8gaW5wdXQgOiBpbnB1dCA9PT0gXCJ0cnVlXCI7XG4gICAgICBjYXNlIFwiaW50ZWdlclwiOlxuICAgICAgICByZXR1cm4gcGFyc2VJbnQoaW5wdXQsIDEwKTtcbiAgICAgIGNhc2UgXCJmbG9hdFwiOlxuICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChpbnB1dCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBwYXJzZVNjYWxhckhlYWRlcihzaGFwZTogU2VyaWFsaXphdGlvbk1vZGVsLCBpbnB1dDogc3RyaW5nKSB7XG4gICAgc3dpdGNoIChzaGFwZS50eXBlKSB7XG4gICAgICBjYXNlIFwidGltZXN0YW1wXCI6XG4gICAgICAgIHJldHVybiB0b0RhdGUoaW5wdXQpO1xuICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICByZXR1cm4gc2hhcGUuanNvblZhbHVlXG4gICAgICAgICAgPyBKU09OLnBhcnNlKHRoaXMudXRmOEVuY29kZXIodGhpcy5iYXNlNjREZWNvZGVyKGlucHV0KSkpXG4gICAgICAgICAgOiBpbnB1dDtcbiAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgIHJldHVybiBpbnB1dCA9PT0gXCJ0cnVlXCI7XG4gICAgICBjYXNlIFwiaW50ZWdlclwiOlxuICAgICAgICByZXR1cm4gcGFyc2VJbnQoaW5wdXQsIDEwKTtcbiAgICAgIGNhc2UgXCJmbG9hdFwiOlxuICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChpbnB1dCk7XG4gICAgICBjYXNlIFwiYmxvYlwiOlxuICAgICAgICByZXR1cm4gdGhpcy5iYXNlNjREZWNvZGVyKGlucHV0KTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHBhcnNlU3RhdHVzQ29kZShcbiAgICBvdXRwdXQ6IGFueSxcbiAgICBzdGF0dXNDb2RlOiBudW1iZXIsXG4gICAgbWVtYmVyOiBNZW1iZXJcbiAgKTogdm9pZCB7XG4gICAgaWYgKCFzdGF0dXNDb2RlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHNoYXBlID0gbWVtYmVyLnNoYXBlIGFzIFN0cnVjdHVyZTtcbiAgICBjb25zdCBtZW1iZXJzID0gc2hhcGUubWVtYmVycztcblxuICAgIGZvciAobGV0IG1lbWJlck5hbWUgb2YgT2JqZWN0LmtleXMobWVtYmVycykpIHtcbiAgICAgIGxldCBtZW1iZXIgPSBtZW1iZXJzW21lbWJlck5hbWVdO1xuICAgICAgaWYgKG1lbWJlci5sb2NhdGlvbiA9PT0gXCJzdGF0dXNDb2RlXCIpIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IG1lbWJlci5sb2NhdGlvbk5hbWUgfHwgbWVtYmVyTmFtZTtcbiAgICAgICAgb3V0cHV0W25hbWVdID0gc3RhdHVzQ29kZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgcmVzb2x2ZUJvZHkoXG4gICAgYm9keTogSHR0cFJlc3BvbnNlPFN0cmVhbVR5cGU+W1wiYm9keVwiXSA9IFwiXCJcbiAgKTogUHJvbWlzZTxVaW50OEFycmF5IHwgc3RyaW5nPiB7XG4gICAgaWYgKHR5cGVvZiBib2R5ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGJvZHkpO1xuICAgIH1cblxuICAgIGxldCBidWZmZXJQcm9taXNlOiBQcm9taXNlPFVpbnQ4QXJyYXk+O1xuICAgIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoYm9keSkpIHtcbiAgICAgIGJ1ZmZlclByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoXG4gICAgICAgIG5ldyBVaW50OEFycmF5KGJvZHkuYnVmZmVyLCBib2R5LmJ5dGVPZmZzZXQsIGJvZHkuYnl0ZUxlbmd0aClcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChpc0FycmF5QnVmZmVyKGJvZHkpKSB7XG4gICAgICBidWZmZXJQcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKG5ldyBVaW50OEFycmF5KGJvZHksIDAsIGJvZHkuYnl0ZUxlbmd0aCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBidWZmZXJQcm9taXNlID0gdGhpcy5ib2R5Q29sbGVjdG9yKGJvZHkpO1xuICAgIH1cblxuICAgIHJldHVybiBidWZmZXJQcm9taXNlO1xuICB9XG5cbiAgcHJpdmF0ZSByZXNvbHZlQm9keVN0cmluZyhcbiAgICBib2R5OiBIdHRwUmVzcG9uc2U8U3RyZWFtVHlwZT5bXCJib2R5XCJdID0gXCJcIlxuICApOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIHJldHVybiB0aGlzLnJlc29sdmVCb2R5KGJvZHkpLnRoZW4oYnVmZmVyID0+XG4gICAgICB0eXBlb2YgYnVmZmVyID09PSBcInN0cmluZ1wiID8gYnVmZmVyIDogdGhpcy51dGY4RW5jb2RlcihidWZmZXIpXG4gICAgKTtcbiAgfVxuXG4gIHByaXZhdGUgcmVzcG9uc2VJc1N1Y2Nlc3NmdWwoc3RhdHVzQ29kZTogbnVtYmVyKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHN0YXR1c0NvZGUgPCAzMDA7XG4gIH1cbn1cbiJdfQ==